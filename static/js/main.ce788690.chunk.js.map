{"version":3,"sources":["logo.svg","AppState.js","Algorithms/Dijkstras.js","Algorithms/BFS.js","Algorithms/DFS.js","Components/Grid.jsx","App.js","reportWebVitals.js","index.js"],"names":["AppContext","createContext","Provider","props","useState","nodeList","setNodeList","start","setStart","end","setEnd","value","NodeList","Start","End","children","path","updateUnvisitedNeighbors","n","grid","neighbors","node","row","col","push","length","filter","neighbor","isVisited","addUnvisitedNeighbors","distance","weight","prev","sortByDistance","queue","sort","a","b","dirRow","dirCol","exploreNeighbors","i","rr","cc","isWall","visitedNodesInOrder","nextNodesStack","DFSutil","Grid","NUM_COLS","nodeRefs","useRef","Nodes","setNodes","isSetStartActive","setIsSetStartActive","isSetEndActive","setIsSetEndActive","isMousedown","setIsMouseDown","isKeydown","setIsKeyDown","menuOpen","setMenuOpen","algo","setAlgo","useEffect","w","window","innerWidth","innerHeight","generateGrid","tempNodes","refRow","j","generateNode","isStartNode","isEndNode","current","hasMoreWeight","Infinity","toggleStartEndNode","choice","newGrid","slice","toggleGridWalls","toBeWalled","visualize","solved","shortestPath","nodes","shift","console","log","solveDijkstras","curr","undefined","unshift","getShortestPath","BFS","retraceShortestPathBFS","pop","DFS","retraceShortestPathDFS","visitedNodes","nodesInShortestPath","setTimeout","classList","add","animateShortestPath","animate","setAlgorithm","setClassNames","className","onClick","resetWalls","location","reload","target","rel","href","algoInfo","width","height","viewBox","fill","xmlns","d","tabIndex","onKeyDown","e","event","shiftKey","onKeyUp","map","ref","el","onMouseDown","onMouseEnter","onMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ce788690.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, { useState, createContext } from 'react'\r\n\r\nexport const AppContext = createContext()\r\n\r\nexport const Provider = (props) => {\r\n    const [nodeList, setNodeList] = useState([])\r\n    const [start, setStart] = useState([])\r\n    const [end, setEnd] = useState([])\r\n\r\n    return(\r\n        <AppContext.Provider value= {{\r\n            NodeList: [nodeList, setNodeList], \r\n            Start: [start, setStart],\r\n            End: [end, setEnd]\r\n        }}>\r\n            {props.children}\r\n        </AppContext.Provider>\r\n    )\r\n}\r\n\r\n","let path = []\r\n\r\nexport function solveDijkstras(grid, start, end) {\r\n    // needs a priority queue, use a sorted array to imitate a priority queue\r\n    const nodes = []\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n          node.distance = Infinity\r\n            nodes.push(node)\r\n      }\r\n    }\r\n\r\n    start.distance = 0\r\n    start.prev = null\r\n\r\n\r\n    while(!!nodes.length) {\r\n        sortByDistance(nodes)\r\n        const n = nodes.shift()\r\n        console.log(n)\r\n        // if the node is a wall, we continue to the next iteration\r\n        if(n.isWall) continue\r\n        // if there is no path between start and end node\r\n        if(n.distance === Infinity) return path\r\n        n.isVisited = true\r\n        path.push(n)\r\n\r\n        // if we found the end node, we return\r\n        if(n === end) return path\r\n        updateUnvisitedNeighbors(n, grid)\r\n    }\r\n}\r\n\r\n// we update the distance of every visited neighbors and set the previous nde of the visited neighbors\r\nfunction updateUnvisitedNeighbors(n, grid) {\r\n    const neighbors = addUnvisitedNeighbors(n, grid)\r\n    for (const neighbor of neighbors) {\r\n        neighbor.distance = n.distance + neighbor.weight\r\n        neighbor.prev = n\r\n    }\r\n}\r\n\r\n// imitating a priority queue, this method returns the lowest distance node\r\nfunction sortByDistance(queue) {\r\n    return queue.sort((a , b) => (a.distance - b.distance))\r\n}\r\n\r\n// we add the unvisited neighbors within the following constraints\r\nfunction addUnvisitedNeighbors(node, grid) {\r\n    const neighbors = []\r\n    let {row, col} = node\r\n\r\n    if(row > 0) neighbors.push(grid[row - 1][col])\r\n    if(col > 0) neighbors.push(grid[row][col - 1])\r\n    if(row < grid.length - 1) neighbors.push(grid[row + 1][col])\r\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\r\n//  return only the nodes that are unvisited\r\n    return neighbors.filter(neighbor => !neighbor.isVisited)\r\n}\r\n\r\n// while curr is not null, we add curr to the start of the shortest path and set curr as the node it came from\r\nexport function getShortestPath(end) {\r\n    const shortestPath = []\r\n    let curr = end\r\n    while(curr !== null) {\r\n        // if there is no path between start and end node\r\n        if(curr === undefined) return shortestPath\r\n        shortestPath.unshift(curr)\r\n        curr = curr.prev\r\n    }\r\n\r\n    return shortestPath\r\n}","// Breadth first search algorithm implementation\r\nlet prev = []\r\nlet queue = []\r\n\r\nconst dirRow = [-1, 1, 0, 0]\r\nconst dirCol = [0, 0, 1, -1]\r\n\r\nexport function BFS(grid, start, end) {\r\n \r\n    start.prev = null\r\n    queue.push(start)\r\n\r\n    while(!!queue.length) {\r\n        let node = queue.shift()\r\n        node.isVisited = true\r\n        if(node.isWall) continue\r\n        if(node === end) return prev\r\n        prev.push(node)\r\n        exploreNeighbors(node, grid)\r\n        // console.log(neighbors)\r\n    }\r\n\r\n    return prev\r\n}\r\n\r\nfunction exploreNeighbors(node, grid) {\r\n    const {row, col} = node\r\n    for(let i = 0; i < 4; i++) {\r\n        let rr = row + dirRow[i]\r\n        let cc = col + dirCol[i]\r\n\r\n        if(rr < 0 || cc < 0) continue\r\n\r\n        if(rr >= grid.length || cc >= grid[0].length) continue\r\n\r\n        if(grid[rr][cc].isWall) continue\r\n        if(grid[rr][cc].isVisited) continue\r\n\r\n        grid[rr][cc].isVisited = true\r\n        grid[rr][cc].prev = node\r\n        queue.push(grid[rr][cc])\r\n    }\r\n}\r\n\r\nexport function retraceShortestPathBFS(end) {\r\n    console.log(`retracing...`, end)\r\n    const shortestPath = []\r\n    let curr = end\r\n    while(curr !== null) {\r\n        // if there is no path between start and end node\r\n        if(curr === undefined) return shortestPath\r\n        shortestPath.unshift(curr)\r\n        curr = curr.prev\r\n    }\r\n\r\n    return shortestPath\r\n}","// Depth first search implementataion\r\nlet visitedNodesInOrder = []\r\nlet nextNodesStack = []\r\n\r\nconst dirRow = [-1, 1, 0, 0]\r\nconst dirCol = [0, 0, 1, -1]\r\n\r\nexport function DFS(grid, start, end) {\r\n    start.prev = null\r\n    start.isVisited = true\r\n    visitedNodesInOrder.push(start)\r\n    nextNodesStack.push(start)\r\n\r\n    while(nextNodesStack.length !== 0) {\r\n        let node = nextNodesStack.pop()\r\n        visitedNodesInOrder.push(node)\r\n        if (node === end) return visitedNodesInOrder\r\n        DFSutil(grid, node)\r\n    }\r\n}\r\n\r\nfunction DFSutil(grid, start) {\r\n    let {row, col} = start\r\n    for(let i = 0; i < 4; i++) {\r\n        let rr = row + dirRow[i]\r\n        let cc = col + dirCol[i]\r\n\r\n        if(rr < 0 || cc < 0) continue\r\n\r\n        if(rr >= grid.length || cc >= grid[0].length) continue\r\n\r\n        if(grid[rr][cc].isWall) continue\r\n        if(grid[rr][cc].isVisited) continue\r\n\r\n        grid[rr][cc].isVisited = true\r\n        nextNodesStack.push(grid[rr][cc])\r\n        grid[rr][cc].prev = start\r\n    }\r\n}\r\n\r\n\r\nexport function retraceShortestPathDFS(end) {\r\n    const shortestPath = []\r\n    let curr = end\r\n    while(curr !== null) {\r\n        // if there is no path between start and end node\r\n        if(curr === undefined) return shortestPath\r\n        shortestPath.unshift(curr)\r\n        curr = curr.prev\r\n    }\r\n\r\n    return shortestPath\r\n}\r\n\r\n","import React, { useState, useEffect, useContext, useRef } from 'react'\r\nimport { AppContext } from '../AppState'\r\nimport { solveDijkstras, getShortestPath } from '../Algorithms/Dijkstras'\r\nimport { BFS, retraceShortestPathBFS } from '../Algorithms/BFS'\r\nimport { DFS, retraceShortestPathDFS } from '../Algorithms/DFS'\r\nimport '../Style.css'\r\n// import Header from './Help-About'\r\n\r\n\r\nconst Grid = () => {\r\n    let NUM_ROWS = 25\r\n    let NUM_COLS = 60\r\n    const DEFAULT_START_ROW = 5\r\n    const DEFAULT_START_COL = 5\r\n    const DEFAULT_END_ROW = 5\r\n    const DEFAULT_END_COL = 15\r\n\r\n    const nodeRefs = useRef([])\r\n\r\n    // const {NodeList, Start, End} = useContext(AppContext)\r\n    const [Nodes, setNodes] = useState([])\r\n    const [start, setStart] = useState({})\r\n    const [end, setEnd] = useState({})\r\n\r\n    const [isSetStartActive, setIsSetStartActive] = useState(false) \r\n    const [isSetEndActive, setIsSetEndActive] = useState(false) \r\n    const [isMousedown, setIsMouseDown] = useState(false)\r\n    const [isKeydown, setIsKeyDown] = useState(false)\r\n    const [menuOpen, setMenuOpen] = useState(false)\r\n    const [algo, setAlgo] = useState('Dijkstra\\'s') \r\n\r\n    useEffect(() => {\r\n        let w = window.innerWidth\r\n        let h = window.innerHeight\r\n        if(w < 500) NUM_COLS = 16\r\n        generateGrid()\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n\r\n    }, [Nodes])\r\n\r\n    const generateGrid = () => {\r\n        let tempNodes = []\r\n        for (let i = 0; i < NUM_ROWS; i++) {\r\n            let row = []\r\n            let refRow= []\r\n            for(let j = 0; j < NUM_COLS; j++) {\r\n                refRow[j] = null\r\n                let n = generateNode(i, j)\r\n                if(n.isStartNode) setStart(n)\r\n                if(n.isEndNode) setEnd(n)\r\n                row.push(n)\r\n            } \r\n            nodeRefs.current[i] = refRow\r\n            tempNodes.push(row)\r\n        }\r\n        setNodes(tempNodes)\r\n    }\r\n\r\n    const generateNode = (row, col) => {\r\n        return {\r\n            row: row,\r\n            col: col,\r\n            isStartNode: row === DEFAULT_START_ROW && col === DEFAULT_START_COL,\r\n            isEndNode: row === DEFAULT_END_ROW && col === DEFAULT_END_COL,\r\n            isWall: false,\r\n            isVisited: false,\r\n            hasMoreWeight: false,\r\n            weight: 1,\r\n            distance: Infinity\r\n        }\r\n    }\r\n\r\n    const handleClick = (e, node) => {\r\n        // if(isSetStartActive === true) {\r\n        //     Nodes.forEach(row => {\r\n        //         row.forEach(n => {\r\n        //             if(n === node) {\r\n        //                 n.isWall = false\r\n        //                 n.isStartNode = true\r\n        //                 setStart(n)\r\n        //             } else n.isStartNode = false\r\n        //         })\r\n        //     });\r\n        //     console.log(Nodes)\r\n        //     setIsSetStartActive(!isSetStartActive)\r\n        // }\r\n        // else if(isSetEndActive === true) {\r\n        //     Nodes.forEach(row => {\r\n        //         row.forEach(n => {\r\n        //             if(n === node) {\r\n        //                 n.isWall = false\r\n        //                 n.isEndNode = true\r\n        //                 setEnd(n)\r\n        //             } else n.isEndNode = false \r\n        //         })\r\n        //     });\r\n        //     console.log(Nodes)\r\n        //     setIsSetEndActive(!isSetEndActive)\r\n        // }\r\n\r\n        // else {\r\n            setNodes(toggleGridWalls(node.row, node.col))\r\n        // }\r\n    }\r\n\r\n    const handleMouseDown = (e, node) => {\r\n        setIsMouseDown(!isMousedown)\r\n        if(node.isStartNode) setIsSetStartActive(true)\r\n        if(node.isEndNode) setIsSetEndActive(true)\r\n        else {\r\n            setNodes(toggleGridWalls(node.row, node.col))\r\n        }\r\n    }\r\n\r\n    const handleMouseEnter = (node) => {\r\n        if(!isMousedown) return\r\n        if(isSetEndActive) toggleStartEndNode(node, 1)\r\n        if(isSetStartActive) toggleStartEndNode(node, 0)\r\n        else setNodes(toggleGridWalls(node.row, node.col))\r\n    }\r\n\r\n    const handleMouseUp = (e, node) => {\r\n        setIsMouseDown(false)\r\n        setIsSetStartActive(false)\r\n        setIsSetEndActive(false)\r\n    }\r\n \r\n    const handleKeyDown = (event) => {\r\n        if(algo === 'Dijkstra\\'s') {\r\n            if(event.shiftKey) setIsKeyDown(true)\r\n        }\r\n    }\r\n\r\n    const resetGrid = () => {\r\n        // let newGrid = Nodes.slice()\r\n        window.location.reload()\r\n        // for(let i = 0; i < NUM_ROWS; i++) {\r\n        //     for(let j = 0; j< NUM_COLS; j++) {\r\n        //     newGrid[i][j].isStartNode = i === DEFAULT_START_ROW && j === DEFAULT_START_COL\r\n        //     newGrid[i][j].isEndNode = i === DEFAULT_END_ROW && j === DEFAULT_END_COL\r\n        //     newGrid[i][j].isWall = false\r\n        //     newGrid[i][j].isVisited = false\r\n        //     newGrid[i][j].hasMoreWeight = false\r\n        //     newGrid[i][j].weight = 1\r\n        //     newGrid[i][j].distance = Infinity\r\n        //     newGrid[i][j].prev = null\r\n        //     nodeRefs.current[i][j].className = 'node'\r\n        //     if(newGrid[i][j].isStartNode) setStart(newGrid[i][j])\r\n        //     if(newGrid[i][j].isEndNode) setEnd(newGrid[i][j])\r\n        //     }\r\n        // }\r\n        // setNodes(newGrid)\r\n        \r\n    }\r\n\r\n    const toggleStartEndNode = (node, choice) => {\r\n        let newGrid = Nodes.slice()\r\n        switch(choice) {\r\n           case 0: {\r\n                for(let i = 0; i < NUM_ROWS; i++) {\r\n                    for(let j = 0; j < NUM_COLS; j++) {\r\n                        if(newGrid[i][j] === node) {\r\n                            newGrid[i][j].isWall = false\r\n                            newGrid[i][j].isStartNode = true\r\n                            setStart(newGrid[i][j])\r\n                        }\r\n                        else newGrid[i][j].isStartNode = false\r\n                    }\r\n                }\r\n                break\r\n            }\r\n            case 1: {\r\n                for(let i = 0; i < NUM_ROWS; i++) {\r\n                    for(let j = 0; j < NUM_COLS; j++) {\r\n                        if(newGrid[i][j] === node) {\r\n                            newGrid[i][j].isWall = false\r\n                            newGrid[i][j].isEndNode = true\r\n                            setEnd(newGrid[i][j])\r\n                        }\r\n                        else newGrid[i][j].isEndNode = false\r\n                    }\r\n                }\r\n                break\r\n            }\r\n        default: break\r\n        }\r\n\r\n        setNodes(newGrid)\r\n    }\r\n\r\n    const resetWalls = () => {\r\n        const newGrid = Nodes.slice()\r\n        for(let i = 0; i < NUM_ROWS; i++) {\r\n            for( let j = 0; j < NUM_COLS; j++) {\r\n                newGrid[i][j].isWall = false\r\n                newGrid[i][j].hasMoreWeight = false\r\n                newGrid[i][j].weight = 1\r\n                \r\n            }\r\n        }\r\n        setNodes(newGrid)\r\n    }\r\n\r\n    const toggleGridWalls = (row, col) => {\r\n        const newGrid = Nodes.slice()\r\n        let toBeWalled = newGrid[row][col]\r\n        if(!toBeWalled.isStartNode && !toBeWalled.isEndNode){\r\n            if(isKeydown) {\r\n            if(toBeWalled.hasMoreWeight) {\r\n                toBeWalled.hasMoreWeight = false\r\n                toBeWalled.weight = 1\r\n            }\r\n            else {\r\n            toBeWalled.hasMoreWeight = true\r\n            toBeWalled.weight = 5\r\n            }\r\n        }\r\n        else toBeWalled.isWall = !toBeWalled.isWall\r\n    }\r\n    return newGrid\r\n    }\r\n\r\n    const nodeIcons = (node) => {\r\n        if(node.isStartNode) return (\r\n        <svg className=\"icon\" width=\"17\" height=\"17\" viewBox=\"0 0 17 17\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n        <path d=\"M8.25 5.25C6.5925 5.25 5.25 6.5925 5.25 8.25C5.25 9.9075 6.5925 11.25 8.25 11.25C9.9075 11.25 11.25 9.9075 11.25 8.25C11.25 6.5925 9.9075 5.25 8.25 5.25ZM14.955 7.5C14.61 4.3725 12.1275 1.89 9 1.545V0H7.5V1.545C4.3725 1.89 1.89 4.3725 1.545 7.5H0V9H1.545C1.89 12.1275 4.3725 14.61 7.5 14.955V16.5H9V14.955C12.1275 14.61 14.61 12.1275 14.955 9H16.5V7.5H14.955V7.5ZM8.25 13.5C5.3475 13.5 3 11.1525 3 8.25C3 5.3475 5.3475 3 8.25 3C11.1525 3 13.5 5.3475 13.5 8.25C13.5 11.1525 11.1525 13.5 8.25 13.5Z\" fill=\"black\"/>\r\n        </svg>\r\n        )\r\n    \r\n        if (node.isEndNode) return (\r\n            <svg className=\"icon\" width=\"11\" height=\"15\" viewBox=\"0 0 11 15\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n            <path d=\"M5.25 0C2.3475 0 0 2.3475 0 5.25C0 9.1875 5.25 15 5.25 15C5.25 15 10.5 9.1875 10.5 5.25C10.5 2.3475 8.1525 0 5.25 0ZM5.25 7.125C4.215 7.125 3.375 6.285 3.375 5.25C3.375 4.215 4.215 3.375 5.25 3.375C6.285 3.375 7.125 4.215 7.125 5.25C7.125 6.285 6.285 7.125 5.25 7.125Z\" fill=\"black\"/>\r\n            </svg>\r\n        )\r\n        if (node.hasMoreWeight) return <svg className=\"icon\" xmlns=\"http://www.w3.org/2000/svg\" height=\"13px\" viewBox=\"0 0 24 24\" width=\"13px\" fill=\"#000000\"><path d=\"M0 0h24v24H0V0z\" fill=\"none\"/><path d=\"M20.57 14.86L22 13.43 20.57 12 17 15.57 8.43 7 12 3.43 10.57 2 9.14 3.43 7.71 2 5.57 4.14 4.14 2.71 2.71 4.14l1.43 1.43L2 7.71l1.43 1.43L2 10.57 3.43 12 7 8.43 15.57 17 12 20.57 13.43 22l1.43-1.43L16.29 22l2.14-2.14 1.43 1.43 1.43-1.43-1.43-1.43L22 16.29l-1.43-1.43z\"/></svg>\r\n    }\r\n\r\n    const visualize = () => {\r\n        let solved, shortestPath\r\n        solved = null\r\n        shortestPath = null\r\n        switch (algo) {\r\n            case 'Dijkstra\\'s':\r\n                solved = solveDijkstras(Nodes, start, end)\r\n                shortestPath = getShortestPath(end)\r\n                break;\r\n            case 'BFS':\r\n                solved = BFS(Nodes, start, end)\r\n                shortestPath = retraceShortestPathBFS(end)\r\n                break;\r\n            case 'DFS':\r\n                solved = DFS(Nodes, start, end)\r\n                shortestPath = retraceShortestPathDFS(end)\r\n                break;\r\n        \r\n            default:\r\n                break;\r\n        }\r\n        animate(solved, shortestPath)\r\n    }\r\n\r\n    function animate(visitedNodes, nodesInShortestPath) {\r\n        for (let i = 0; i <= visitedNodes.length; i++) {\r\n            // here we are animating the shortest path we got\r\n          if (i === visitedNodes.length) {\r\n            setTimeout(() => {\r\n              animateShortestPath(nodesInShortestPath);\r\n            }, 10 * i);\r\n            return;\r\n          }\r\n        //   here we are animating the visited nodes\r\n          setTimeout(() => {\r\n            const node = visitedNodes[i];\r\n            console.log(`node`, node)\r\n            if(!node.isWall) {\r\n                nodeRefs.current[node.row][node.col].classList.add('node-visited')\r\n            }\r\n          }, 10 * i);\r\n        }\r\n      }\r\n    \r\n      function animateShortestPath(nodesInShortestPath) {\r\n        for (let i = 0; i < nodesInShortestPath.length; i++) {\r\n          setTimeout(() => {\r\n            const node = nodesInShortestPath[i];\r\n            nodeRefs.current[node.row][node.col].classList.add('node-shortest-path')\r\n          }, 50 * i);\r\n        }\r\n      }\r\n\r\n    const algoInfo = () => {\r\n        switch (algo) {\r\n            case 'Dijkstra\\'s':\r\n                return <p>Dijkstra's algorithm is <b>weighted</b> and guarantees a shortest path!<br/><p className=\"hint\">Hint: Hold shift key while drawing walls to add weights.</p></p>\r\n            case 'BFS':\r\n                return <p>Breadth First Search algorithm is <b>unweighted</b> and guarantees a shortest path!</p>\r\n            case 'DFS':\r\n                return <p>Depth First Search algorithm is <b>unweighted</b> and does not guarantee a shortest path!</p>\r\n            default:\r\n                return ''\r\n        }\r\n    }\r\n\r\n    const menuClass = () => {\r\n        if(menuOpen) return 'selectAlgo'\r\n        return 'selectAlgoHidden'\r\n    }\r\n\r\n    const setAlgorithm = (algo) => {\r\n        setAlgo(algo)\r\n        setMenuOpen(!menuOpen)\r\n    } \r\n\r\n\r\n    const setClassNames = (n) => {\r\n        if(n.isWall) return 'node wall'\r\n        // if(n.isStartNode) return 'node start'\r\n        // if(n.isEndNode) return 'node end'\r\n        else return 'node'\r\n    }\r\n\r\n    return(\r\n        <>\r\n        <h3 className=\"logo\">Pathfinder</h3>\r\n        <div className=\"btns\">\r\n        <button onClick={() => setMenuOpen(!menuOpen)}>Select Algorithm</button>\r\n        <button className='visualizeBtn' onClick={() => visualize()}>Visualize {algo}</button>\r\n        <button onClick={() => resetWalls()}>Reset walls {'&'} weights</button>\r\n        <button onClick={() => resetGrid()}>Reset Grid</button>\r\n        <a target=\"_blank\" rel=\"noreferrer\" href=\"https://github.com/Karthikb777/Pathfinder\">Source Code</a>\r\n        </div>\r\n        <div className=\"algoInfo\">{algoInfo()}</div>\r\n        <div className={menuClass()}>\r\n            <ul>\r\n                <li onClick={() => setAlgorithm('Dijkstra\\'s')}>Dijkstra's</li>\r\n                <li onClick={() => setAlgorithm('BFS')}>Breadth first search</li>\r\n                <li onClick={() => setAlgorithm('DFS')}>Depth first search</li>\r\n            </ul>\r\n        </div>\r\n        <div>\r\n            <li className=\"info\">\r\n                <ul>\r\n                    <li className=\"infoField\">\r\n                        <ul className=\"infoIcon infoSvg\">\r\n                            <svg className=\"icon\" width=\"15\" height=\"15\" viewBox=\"0 0 17 17\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n                            <path d=\"M8.25 5.25C6.5925 5.25 5.25 6.5925 5.25 8.25C5.25 9.9075 6.5925 11.25 8.25 11.25C9.9075 11.25 11.25 9.9075 11.25 8.25C11.25 6.5925 9.9075 5.25 8.25 5.25ZM14.955 7.5C14.61 4.3725 12.1275 1.89 9 1.545V0H7.5V1.545C4.3725 1.89 1.89 4.3725 1.545 7.5H0V9H1.545C1.89 12.1275 4.3725 14.61 7.5 14.955V16.5H9V14.955C12.1275 14.61 14.61 12.1275 14.955 9H16.5V7.5H14.955V7.5ZM8.25 13.5C5.3475 13.5 3 11.1525 3 8.25C3 5.3475 5.3475 3 8.25 3C11.1525 3 13.5 5.3475 13.5 8.25C13.5 11.1525 11.1525 13.5 8.25 13.5Z\" fill=\"black\"/>\r\n                            </svg>\r\n                        </ul>\r\n                        <ul className=\"infoText\">Start node</ul>\r\n                    </li>\r\n                </ul>\r\n                <ul>\r\n                    <li className=\"infoField\">\r\n                        <ul className=\"infoIcon infoSvg\">\r\n                            <svg width=\"11\" height=\"15\" viewBox=\"0 0 11 15\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n                            <path d=\"M5.25 0C2.3475 0 0 2.3475 0 5.25C0 9.1875 5.25 15 5.25 15C5.25 15 10.5 9.1875 10.5 5.25C10.5 2.3475 8.1525 0 5.25 0ZM5.25 7.125C4.215 7.125 3.375 6.285 3.375 5.25C3.375 4.215 4.215 3.375 5.25 3.375C6.285 3.375 7.125 4.215 7.125 5.25C7.125 6.285 6.285 7.125 5.25 7.125Z\" fill=\"black\"/>\r\n                            </svg>\r\n                        </ul>\r\n                        <ul className=\"infoText\">End node</ul>\r\n                    </li>\r\n                </ul>\r\n                <ul>\r\n                    <li className=\"infoField\">\r\n                        <ul className=\"infoIcon infoWall\"></ul>\r\n                        <ul className=\"infoText\">Walls</ul>\r\n                    </li>\r\n                </ul>\r\n                {algo === 'Dijkstra\\'s'?\r\n                <ul>\r\n                    <li className=\"infoField\">\r\n                        <ul className=\"infoIcon infoSvg\">\r\n                        <svg className=\"icon\" xmlns=\"http://www.w3.org/2000/svg\" height=\"15px\" viewBox=\"0 0 24 24\" width=\"15px\" fill=\"#000000\"><path d=\"M0 0h24v24H0V0z\" fill=\"none\"/><path d=\"M20.57 14.86L22 13.43 20.57 12 17 15.57 8.43 7 12 3.43 10.57 2 9.14 3.43 7.71 2 5.57 4.14 4.14 2.71 2.71 4.14l1.43 1.43L2 7.71l1.43 1.43L2 10.57 3.43 12 7 8.43 15.57 17 12 20.57 13.43 22l1.43-1.43L16.29 22l2.14-2.14 1.43 1.43 1.43-1.43-1.43-1.43L22 16.29l-1.43-1.43z\"/></svg>\r\n                        </ul>\r\n                        <ul className=\"infoText\">Weights</ul>\r\n                    </li>\r\n                </ul> :'' }\r\n                <ul>\r\n                    <li className=\"infoField\">\r\n                        <ul className=\"infoIcon infoVisited\"></ul>\r\n                        <ul className=\"infoText\">Visited nodes</ul>\r\n                    </li>\r\n                </ul>\r\n                <ul>\r\n                    <li className=\"infoField\">\r\n                        <ul className=\"infoIcon infoPath\"></ul>\r\n                        <ul className=\"infoText\">Path nodes</ul>\r\n                    </li>\r\n                </ul>\r\n            </li>\r\n        </div>\r\n        <table className=\"grid\"\r\n        tabIndex='1'\r\n        onKeyDown={(e) => handleKeyDown(e)}\r\n        onKeyUp={()=> setIsKeyDown(false)}\r\n        >\r\n            <tbody>\r\n               {Nodes.map((row) => {\r\n                   return (\r\n                       <tr>\r\n                           {row.map(n => {\r\n                                return <td className={setClassNames(n)} \r\n                                ref={(el) => nodeRefs.current[n.row][n.col] = el}\r\n                                onMouseDown={(e) => handleMouseDown(e, n)}\r\n                                onMouseEnter={(e) => handleMouseEnter(n)}\r\n                                onMouseUp={(e) => handleMouseUp(e, n)}\r\n                                onClick={(e) => handleClick(e, n)}>\r\n                                    {nodeIcons(n)}\r\n                                </td>\r\n                               })\r\n                           }\r\n                       </tr>\r\n                   )\r\n               })}\r\n            </tbody>\r\n        </table>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default Grid","import {BrowserRouter as Router, Route, Switch} from 'react-router-dom'\nimport logo from './logo.svg';\nimport Grid from './Components/Grid'\nimport HelpAbout from './Components/Help-About'\nimport './Style.css';\n\nfunction App() {\n  return (\n    <div className=\"container\">\n          {/* <h3 className=\"logo\">Pathfinder</h3> */}\n          {/* <p className=\"subTitle\">A visualization of different pathfinding algorithms.</p> */}\n          {/* <HelpAbout /> */}\n          <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React, {useContext} from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport {Provider} from './AppState';\nimport reportWebVitals from './reportWebVitals';\n\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}